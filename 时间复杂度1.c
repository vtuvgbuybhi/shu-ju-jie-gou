#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

//算法的复杂度--- 时间复杂度   、   空间复杂度

//时间复杂度  --》衡量一个算法的运行快慢
//空间复杂度  --》衡量一个算法运行所需要的额外空间（不在特别关注空间复杂度）

//算法中的基本操作的执行次数，为算法的时间复杂度

//嵌套循环时间复杂度的计算   --（时间复杂度是一个函数）

//int main()
//{
//	int N;
//	for (int i = 0; i < N; i++)
//	{
//		for (int j = 0; j < N; j++)
//		{
//			;
//		}
//	}
//	int count = 10;
//	while (count--)
//	{
//		;
//	}
//	return 0;
//}

//上面嵌套循环的时间复杂度   :  F(N)=  N*N+10    是一个关于N的函数式

//N=10    F(N)=110
//N=100   F(N)=10010
//N=1000  F(N)=1000010
//当我们的N越大时，后一项对我们的结果影响越小
//
//实际上我们时间复杂度的计算，我们并不需要计算精确的执行次数，而只需要大概执行次数
//这里我们所以大O的渐进表示法

//时间复杂度:   O(N^2)

//大O的渐进表示法   --》  推导大O阶方法
//1.  用常数1取代运行时间中的所有加法常数
//2.在修改后的运行次数函数中，只保留最高阶项
//3.如果最高阶项存在且不是1，则去除与这个项目相乘的常数 ，得到的结果计算大O阶



//int main()
//{
//	int N;
//	for (int i = 0; i < 2 * N; i++)
//	{
//		;
//	}
//	int count = 10;
//	while (count--)
//	{
//		;
//	}
//	return 0;
//}
//时间复杂度 :  F(N)=2*N+10
//估算后的时间复杂度:     O(N)
//为什么不是O(2*N)呢，当我们的N无穷大时  N与2N 都在同一个级别    （相乘的这个系数可以忽略掉）


//void Func3(int N, int M)
//{
//	for (int i = 0; i < M; i++)
//	{
//		;
//	}
//	for (int j = 0; j < N; j++)
//	{
//		;
//	}
//}

//M远大于N  --》O(M)
//N远大于M  --》O(N)
//M和N差不多大 --》可以是O（M）  也可以是O(N)
//不知道M和N的大小--》O(M+N)


/*void Func4(int N)
{
	for (int k = 0; k < 100; k++)
	{
		;
	}
}

//F（N）=100
时间复杂度  O（1）*/  //用常数1去替代加法当中的所有加法常数

//计算strchr的时间复杂度
//
//
//const char*strchr(const char*str,int character)//查找函数
//
//while (*str)
//{
//	if (*str == character)
//		return str;
//	else
//		++str;
//}
//
//hello world
//
//字符串数组的大小不知道用N代表大小
//
//假设查找的是   h      O(1)             最好情况:任意输入规模的最小运行次数（下界）
//               w      O(N/2)             平均情况:输入任意规模的期望运行次数
//               d       O(N)            最坏情况:输入任意规模的最大运行次数（上界）
//
//当一个算法随着输入不同，时间复杂度不同，时间复杂度做悲观预期，看最坏情况



//冒泡排序时间复杂度
//
//void Bubble_sort(int arr[], int n)
//{
//	for (int i = 0; i < n; i++)
//	{
//		int j = 0;
//		for (j = 0; j < n - i; j++)
//		{
//			if (arr[j] > arr[j + 1])
//			{
//				int temp = arr[j+1];
//				arr[j + 1] = arr[j];
//				arr[j] = temp;
//			}
//		}
//	}
//}
//       总的循环次数:       N-1   N-2   N-3  ……   1
//
//         F(N)= ( N*(N-1))/2
//
//时间复杂度  : F(N) = (N * (N - 1)) / 2
// O阶复杂度:     O(N^2)



//二分查找时间复杂度

//void BinarySearch(int arr[], int n, int x)
//{
//	int begin = 0;
//	int end = n-1;
//	while (begin < end)
//	{
//		int mid = (begin + end) / 2;
//		if (arr[mid] < x)
//		{
//			begin = mid + 1;
//		}
//		else if(arr[mid]>x)
//		{
//			end = mid-1;
//		}
//		else
//		{
//			return mid;
//		}
//	}
//}

//算时间复杂度不能只去看几层循环，而要去看他的思想

//二分查找   

//最好           O(1)                        一次在中间找到  
//最坏    O(log N)以2为底的对数             

//时间复杂度  O(log N)  以2为底N的对数

//二分查找非常牛逼

//1000个数         大概查找 10次
//100w                      20次
//10亿                      30次


//计算阶乘递归Fac的时间复杂度

//Fac(size_t N)
//{
//	if (0 == N)         
//	{
//		return 1;
//	}
//	return Fac(N - 1) * N;
//}

//Fac(N)  -->  Fac(N-1) -->  ……  --》Fac(1)

//时间复杂度  O（N）

//递归算法:递归次数 * 每次递归调用的次数


//计算斐波那契数列递归
//Fib(size_t N)
//{
//	if (N < 3)                                        -
//	{                                                 |
//		return 1;                                     |  每次递归的调用次数是O(1)
//	}                                                 |
//	return Fib(N - 1) + Fib(N - 2);                   -
//}
//
//   2^0                           F(N)                                                  F(5)
//   2^1				F(N-1)            F(N-2)                               F(4)                     F(3)
//   2^2			F(N-2)   F(N-3)     F(N-3)   F(N-4)                   F(3)    F(2)              F(2)    F(1)
//				……                                                  F(2)   F(1)
//2^(N-2)         F(3)         -------------------
//2^(N-1)			F(1)   F(2) |   这一块是空的    |
//                             --------------------
//
//Fib(N)= 2^0+2^1+……+2^(N-1) -  X(减去那一块空的)  * O(1)(乘上每次递归调用的次数)
//        X远小于 2^N
//    等比数列求和 :    2^N-1
//             
//时间复杂度 O(2^N)

//O(2^N)  当N=50时就很慢了
//long long Fib(size_t N)
//{
//	if (N < 3)
//	{
//		return 1;
//	}
//	return Fib(N - 1) + Fib(N - 2);
//}
//int main()
//{
//	printf("%lld ", Fib(100));
//
//	return 0;
//}



//空间复杂度  --》  计算运行过程当中临时的额外变量

//冒泡排序的空间复杂度
//void Bubble_sort(int arr[], int n）//这里的n和arr数组是本身需要的  --》我们算的额外的空间大小（这个算法定义的变量个数）
//{
//	for (int i = 0; i < n; i++)
//	{
//		int j = 0;
//		for (j = 0; j < n - i; j++)
//		{
//			if (arr[j] > arr[j + 1])
//			{
//				int temp = arr[j+1];
//				arr[j + 1] = arr[j];
//				arr[j] = temp;
//			}
//		}
//	}
//}

//先定义一个i   再定义一个j
//j这个循环结束  j销毁了  再进入下一次循环的时候在定义一个j   
//这个j与之前的j公用同一块空间 
//
//空间复杂度  O(1)    1不是代表一个是代表常数个（这里的冒泡排序是3个（i，j，temp））


//计算斐波那契数列的空间复杂度

//long long Fibonacci(size_t n)   //创建N个数的数组
//{
//	if (n == 0)
//	{
//		return NULL;
//	}
//	long long* fibArray = (long long*)malloc((n + 1) * sizeof(long long));
//	fibArray[0] = 0;
//	fibArray[1] = 1;
//	for (int i = 2; i <= n; i++)
//	{
//		fibArray[i] = fibArray[i - 1] + fibArray[i - 2];
//	}
//	return fibArray;
//}
//
////创建了N个变量  --》 放入数组当中去
//空间复杂度    :   O(N)
//时间复杂度    :   O(N)
//
////如果我们想求第N个数
//我们直接用3个数进行交替的走
//空间复杂度还可以优化  :O(1)



//long long Fac(size_t N)
//{
//	if (N == 1)
//	{
//		return 1;
//	}
//	return Fac(N - 1) * N;
//}
//看递归的深度   --》 看栈帧的消耗

//F(N)--->F(N-1)  --->F(N-2) ……  --》F(1)
//调用了N次函数  --》共创建了N个栈帧
//
//空间复杂度;  O(N)


//斐波那契递归数列的空间复杂度
//Fib(size_t N)
//{
//	if (N < 3)                                        
//	{                                                 
//		return 1;                                     
//	}                                                 
//	return Fib(N - 1) + Fib(N - 2);                   
//}

//空间是可以重复利用，不累计的
//时间是一去不复返，累计的

  //                           F(N)   
  //                F(N-1)              F(N-2)
		//	 F(N-2)  F(N-3)     F(N-3)     F(N-4)
  // N要算N-1和N-2    不过会先算N-1
  //N-1要算N-3和N-2    不过会先算N-2

  //最多建立N个栈帧  --》重复利用


//       F(N)     
//        |
//	   F(N-1)----------
//	    |             | 
//	   F(N-2)         |
//		|             |
//	   F(N-3)         |
//		|             |
//	   F(N-4)         |
//		|             |
//	   F(1)        <---
//
//直接先算N---》1  
//调用F（N-1）的时候在返回去用之前调用过的F（N-1）空间
//
//时间复杂度O(N)













